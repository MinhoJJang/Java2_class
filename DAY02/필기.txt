평일 java2

Zoom 회의 참가
https://us06web.zoom.us/j/9742331340?pwd=Vk54K0Q0QnNOSEZFbHRCNUNBQzBRQT09

회의 ID: 974 233 1340
암호: 1900c
--------------------------------------------------------------------------------
1. Override
 1-1. @Override 옵션
  - 메서드 재정의 과정에서 오타가 발생한 경우
  - 부모 클래스의 say() 메서드를 재정의 하는 과정에서 개발자의 실수로 
  "sai()"라고 메서드가 추가되었다면 Java는 새로운 메서드를 추가한 것으로 인식하고
  특별한 에러를 표시하지 않는다.
  - say() 메서드가 재정의 된 것으로 생각한 개발자는 이 경우 의도하지 않은
  결과를 만나게 될 것이다.
  - "@Override"는 이 키워드가 명시된 위치 아래에 정의되는 메서드가
  부모 클래스에 존재하지 않을 경우 구문 에러로 처리한다.
  - 부모 클래스의 메서드를 재정의 하고자 할 경우, 의도치 않은 실수를 예방하기 위한
  '오타방지용 옵션'이다.
  - 여러 개의 메서드를 재정의 한다면 재정의 되는 모든 메서드들 위에 각기 명시해야 한다.

2. 다형성 - 오버로드(overload)
  2-1. 메서드 오버로드
   - 원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상 존재할 수 없지만,
   이를 가능하게 하는 예외적인 처리 기법.

  2-2. 이름이 동일한 메서드를 정의하기 위한 조건
   - 메서드간의 파라미터가 서로 달라야 한다.
	-> 파라미터의 데이터 타입이 다르다.
	(데이터 형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로 인식된다.)
	-> 파라미터의 개수가 다르다.
	-> 서로 다른 데이터형을 갖는 파라미터들의 전달 순서가 다르다.
   - 리턴형이 다른 경우는 오버로드의 성립에 아무런 영향을 주지 않는다.

  2-3. 오버로드 예시
   - 파라미터의 데이터 형이 서로 다르기 때문에 오버로드 성립

	public void foo( int a ){}
	public void foo( long a ){}

   - 파라미터의 개수가 서로 다르기 때문에 오버로드 성립

	public void foo( int a ){}
	public void foo( int a, int b ){}

   - 데이터 형의 전달 순서가 서로 다르기 때문에 오버로드 성립

	public void foo( int a, long b ){}
	public void foo( long a, int b ){}

  2-4. System.out.println()
   - 오버로드는 하나의 메서드를 호출할 수 있는 모든 경우의 수를 미리 준비해 놓음으로서,
   메서드를 만드는 측은 번거로울 수 있지만 메서드를 호출하는 측은 데이터 타입을
   신경쓰지 않고 편리하게 사용할 수 있게 하기 위함이다.

  2-5. 객체 생성 방법의 다양화
   - 생성자 역시 메서드의 한 종류이므로 Overload가 가능하다.
   - 생성자를 Overload할 경우, 해당 클래스에 대해 '객체를 생성하는 방법'을
   다양하게 준비할 수 있게 된다.

  2-6. this키워드를 사용한 생성자 Overload
   - this 키워드의 용법
	-> 메서드처럼 사용할 경우, 현재 클래스의 다른 생성자를 의미한다.
   - this 키워드를 사용하여 생성자 Overload를 간결하게 처리하기
	-> 파라미터가 서로 다른 생성자들이 하나의 완전한 생성자를 호출하도록 하여
	데이터의 초기화를 한곳에서 일괄적으로 처리하도록 구현할 수 있다.

3. 객체 형변환과 객체 배열
  3-1. 객체 형변환
   - Java 기본 유형의 데이터들처럼 객체 참조변수의 경우에도 형변환(casting)이 이루어진다.
   - 서로 다른 클래스 유형으로부터 나온 객체 참조변수들 간의 대입에는 
   일정한 규칙이 있다.

	Parent parent = new Child();

   - 위의 대입연산에서 왼쪽 항(Parent)과 오른쪽 항(Child)의 객체 유형이 서로 다른 경우,
   두 유형이 서로 상속 관계에 있고 왼쪽 객체(Parent)가 오른쪽 객체(Child)의 상위 클래스인
   경우에만 암묵적 형 변환이 일어난다.
   - 하위 클래스에서 상위클래스 유형으로 할당하는 것은 가능하나, 그 반대의 경우에는
   명시적 형 변환을 해야 한다.



  3-2. 객체간의 암묵적 형변환
	A a1 = new B();
	A a2 = new X();
	----------------
	A a3 = new C();
	A a4 = new Y();
	----------------
	B b1 = new C();
	X x1 = new Y();
	----------------
	C c = new C();
	B b2 = c;
	----------------
	Y y = new Y();
	X x2 = y;





















