평일 java2

Zoom 회의 참가
https://us06web.zoom.us/j/9742331340?pwd=Vk54K0Q0QnNOSEZFbHRCNUNBQzBRQT09

회의 ID: 974 233 1340
암호: 1900c
----------------------------------------------------------------------------
1. 객체형변환과 객체배열
 1-1. 암묵적 형변환과 메서드 오버라이드
  - 암묵적 형변환은 부모를 상속받는 자식객체의 기능을 부모에게 물려받은기능만 
  사용하도록 제한한다.
  - 그러므로 암묵적 형변환이 발생하게 되면 오버라이드된 기능만 사용가능하고, 추가적으로
  구현한 기능은 사용할 수 없다.
  - 주의할 점은 기능의 제한이지 기능의 변경은 아니라는 것이다.
  

  - 객체 형변환을 통해서 상속관계의 객체를 부모형태로 변환하면 클래스의 종류를
  구분하지 않고 일관된 기능을 호출할 수 있고, 객체가 상위클래스형태로 형변환 되더라도
  Override된 자신의 기능은 잃지않는다는 것을 알게 되었다.
  
	Unit u1 = new Army();
	Unit u2 = new Navy();
	Unit u3 = new Airforce();

	u1.attack();
	u2.attack();
	u3.attack();

   - 하지만, 추가적으로 구현한 기능은 사용할 수 없게 되므로 원래의 기능을 다시 사용할 수 있는
   방법이 필요해 졌다.

	// 부모 클래스가 가지고 있는 기능이 아니므로 에러
	u1.tank();
	u2.nucleus();
	u3.bombing();

  1-2. 명시적 형변환
   - 부모 클래스의 객체를 자식 클래스 형태로 변환하는 것
   - 형변환을 위해서는 다음과 같이 변환할 클래스 이름을 명시적으로 지정해 주어야 한다.

	ChildClass child = (ChildClass)parent;

  1-3. 명시적 형변환의 조건
   - 객체가 최초로 생성될 때 자식 클래스 형태로 생성되고, 부모 형태로 암묵적 형변환이 된 상태를
   다시 원래의 자식 클래스 형태로 되돌릴 경우에만 가능하다.

	ChildClass child1 = new ChildClass();
	ParentClass parent = child1;
	ChildClass child2 = (ChildClass)parent;

  1-4. 명시적 형변환이 가능한 경우
   - 'new'로 할당된 원본 클래스로 되돌아가는 경우만 가능하다.

	Army army1 = new Army();
	Unit u = army1;		// 암묵적 형변환
	Army army2 = (Army)u;	// 명시적 형변환
	--------------------------------------
	Unit u = new Navy();	// 암묵적 형변환
	Navy navy = (Navy)u;	// 명시적 형변환

  1-5. 명시적 형변환이 불가능한 경우
   - 최초 객체 생성이 부모 형태로 만들어진 경우 불가능하다.

	Unit u = new Unit();
	Army army = (Army)u;

   - 최초 생성된 것과 다른 형식으로 변환하는 것은 불가능하다.

	Army army = new Army();
	Unit u = army;		// 암묵적 형변환
	Navy navy = (Navy)u;

   - 위의 두 경우 모두 문법적인 오류는 없기 떄문에, 이클립스에서는 에러를 검출하지 못한다.
   하지만 프로그램을 실행시켰을 경우에는 에러가 발생한다.

2. 객체 배열
  2-1. 객체 배열이란?
   - 일반 데이터 타입의 배열과 동일한 개념으로, 
   같은 클래스의 객체 여러개를 그룹화 할 수 있다.
   - 일반 데이터 형의 배열 생성과 객체 배열 생성 비교
	-> 일반 데이터 형 배열의 경우
		
		int[] data = new int[3];

	-> 객체 배열의 경우
		
		Army[] data = new Army[3];

   - 각 경우에 대한 배열의 요소 할당처리
	-> 일반 데이터형은 단순히 값을 대입하지만, 
  	객체 배열은 'new'를 사용하여 객체에 할당해야 한다.

	-> 일반 데이터의 형 배열의 경우
	
		data[0] = 1;
		data[1] = 10;
		data[2] = 100;

	-> 객체 배열의 경우

		data[0] = new Army();
		data[1] = new Army();
		data[2] = new Army();

  2-2. 내용정리
   - 객체 형변환
	-> 같은 부모 클래스에서 파생된 서로 다른 자식 클래스의 객체들은
	부모형태로 암묵적 형변환이 되어 일관된 형식으로 사용 가능하다.

   - 객체 배열
	-> 동일한 클래스의 객체는 배열로 묶어서 여러 개를 한꺼번에
	제어할수 있다.

  2-3. 부모클래스 배열에 자식 클래스의 객체를 넣기
   - 배열의 생성이 부모 클래스로 지정되었을 경우,
   모든 자식 클래스의 객체들은 그 배열에 포함될 수 있다.

   	Unit[] unit = new Unit[3];

	// 배열의 요소 할당 과정에서 암묵적 형변환이 이루어진다.
	unit[0] = new Army();
	unit[1] = new Navy();
	unit[2] = new AirForce();

  2-4. 일괄처리 가능
   - 서로 다른 객체를 부모 형태의 배열에 담게 되면, 반복문으로 일괄처리가 가능하다.
   - 이 때 배열의 각 요소를 통해 사용하는 메서드가 Override되어 있을 경우,
   부모의 메서드가 아니라 자신이 재정의한 기능을 뜻한다.

	for( int i = 0; i<unit.length; i++ ){
		unit[i].attack();
	}

  2-5. 원래 기능으로 복귀하기
   - 배열의 각 요소가 확장한 기능을 사용하기 위해서는 원래의 클래스 형태로
   명시적 형변환이 이루어 져야 한다.
   - 하지만 반복적으로 처리되는 과정에서 몇 번째 요소가 어떤 클래스에서 최초 생성되었는지를
   판단하기란 쉽지 않다.
   - instanceof 연산자
   	-> instanceof 연산자는 어떤 객체에 대한 출처를 판단하여
	boolean형으로 결과를 반환한다.

	if( unit[0] instanceof Army ){
		Army temp = (Army)unit[0];
	}

 	-> 반복문 안에서 사용할 경우 배열의 크기나 인덱스의 위치에 종속되지 않고,
	배열에 속해 있는 모든 객체들에 대해 명시적 형변환을 처리할 수 있다.
















